# 4장 아키텍처

- DDD 의 가장 큰 장점 중 하나는 특정 아키텍처의 사용을 요구하지 않는다는 점이다.
- 구체적인 소프트웨어 품질에 관한 실제 요구가 아키텍처 스타일과 패턴의 사용을 유도해야 하고 이러한 방법이 리스크 주도 접근법 이다.
- 사용중인 모든 아키텍처의 영향을 정당화하고, 정당화할 수 없다면 시스템에서 제거해야 한다.
- 기능적 요구사항 없이는 필요한 소프트웨어 품질을 결정할 수 없고 이는 유스케이스 주도 아키텍처 접근법을 사용한 소프트웨어 개발이 오늘날에도 여전히 유효하다는 의미이다.

## 계층

- 도메인 모델과 비지니스 로직의 표현을 격리하고, 인프라 의존성이나 사용자 인터페이스나 비지니스 로직을 제외한 애플리케이션 로직 등도 모두 제거하라.
- 복잡한 프로그램은 계층으로 나눠라. 각 계층 내에선 응집력 있고 하위 계층들에만 의존하는 설계를 만들어라.
- 사용자 인터페이스 계층
    - 사용자의 뷰와 요구사항 문제를 다루는 코드만 포함
    - 깊은 비지니스 지식을 표현하는 대단위 유효성 검사는 오직 모델로만 제한하는 편이 좋다.
    - 이 계층은 오픈 호스트 서비스의 형태로 API 서비스를 원격 호출하는 수단을 제공할 수 있음.
- 애플리케이션 계층
    - 영속성 트랜잭션과 보안을 제어할 수 있으며 이벤트 기반의 알림을 다른 시스템으로 보낼 수도 있다.
    - 도메인 모델의 직접적인 클라이언트가 되며 매우 경량으로 유지되고, 애그리게잇 과 같은 도메인 객체에게 오퍼레이션 수행을 지시한다.
    - 애플리케이션 레이어에서 도메인 이벤트에 대한 처리를 책임지도록 한다.
        - 도메인 모델이 고유한 핵심 문제만 알면 되는 자유로움을 갖게됨
        - 도메인 이벤트 게시자를 경량으로 유지할 수 있다.
        - 도메인 모델이 메세징 인프라스트럭쳐 의존성으로부터 해방된다.
- 도메인 계층
    - 핵심 도메인 객체가 인프라 계층을 바로 사용하는 상황은 피해야 한다.
        - 이러한 문제를 피하기 도메인 계층에서 참조하는 인터페이스를 만든다.
        - 인프라 계층에서는 인터페이스에 대한 모듈을 구현해 기술적 클래스를 숨길 수 있다.
- 인프라 계층
    - 전통적인 계층 아키텍처에서 인프라는 가장 아래에 있다.
    - 높은 수준의 계층은 제공된 기술적 기능의 재사용을 위해 낮은 수준의 컴포넌트와 연결된다.
    - 핵심 도메인 모델 객체를 인프라에 연결하면 안된다.

### 의존성 역행 원리

- 의존성이 영향을 주는 방식을 조정함으로써 전통적인 계층 아키텍처를 개선하는 방법
    - 상위 수준의 모듈은 하위 수준 모듈에 의존해선 안 된다. 둘 모두는 반드시 추상화에 의존해야 한다.
    - 추상화는 세부사항에 의존해선 안된다. 세부사항은 추상화에 의존해야 한다.

## 헥사고날 또는 포트와 어댑터

- 다양한 이질적 클라이언트가 동등한 지위에서 시스템과 상호작용하도록 함으로써 그 목표를 달성한다.
- 유스케이스를 염두에 두고 설계할뿐 지원되는 클라이언트를 고려하진 않는다.
- 테스트를 위해 어댑터를 쉽게 개발할 수 있다.
- 시스템에 필요한 다른 여러 아키텍처를 지원할 때 든든한 기반이 된다.

## 서비스 지향

- 토마스 얼에 의해 정의된 SOA 의 원리
    - 서비스 계약: 서비스는 그 목적과 기능을 하나 이상의 설명 문서에 계약으로써 표현한다.
    - 서비서의 느슨한 결합: 서비스는 의존성을 최소화 하고 오직 서로에 대해서만 알고 있다.
    - 서비스 추상화: 서비스는 그들의 계약만을 게시하고, 클라이언트로부터 내부 로직을 숨긴다.
    - 서비스 재사용성: 서비스는 좀 더 대단위의 큰 서비스를 만들기 위해 다른 상대에게 재사용될 수 있다.
    - 서비스 자율성: 서비스는 하위 환경과 자원을 제어하며 독립적으로 유지되고, 이로부터 서비스는 일관성과 신뢰성을 유지한다.
    - 서비스 무상태: 서비스는 상태 관리의 책임을 소비자에게 두며, 이는 서비스 자율성을 위한 제어 과정과 충돌하지 않도록 하기 위해서다.
    - 서비스 발견성: 메타데이터로 서비스를 기술함으로써 검색이 가능해지고 서비스 계약을 이해할 수 있는데, 이를 통해 서비스는 (재)사용 가능한 자산이 된다.
    - 서비스 구성성: 서비스는 크기나 컴포지션의 복잡성과는 무관하게, 더 대단위의 서비스를 구성하는 일부가 될 수 있다.
- 하나 이상의 기술적 서비스 엔드포인트를 사용해 바운디드 컨텍스트의 크기를 나타내려 한다면 단일 엔터프라이즈 내에 바운디드 컨텍스트 미니어처가 수없이 존재하게 될 수 있다.
    - 이 접근법에 기술적 이점이 있는것처럼 보일지라도, 이는 전략적 DDD 의 목적을 실현하지는 못한다.
    - 실제론 언너을 조각 낼 뿐이며, 완전하고 포괄적인 유비쿼터스 언어에 기반한 깨끗하고 잘 모델링된 도메인을 구축하는 일과는 상반된 작업이다.
    - 비정상적으로 바운디드 컨텍스트를 조각내는 일은 SOA 정신과도 맞지 않으며, 이를 가치있게 받아들인다면, 전략적 DDD 와도 아주 잘 어울리게 된다.

## REST: 표현 상태 전송

### 아키텍처 스타일로서의 REST

- 아키텍처 스타일이란 특정 설계를 위한 설계패턴이 무엇인지에 관한 구조적인 큰 그림이다.
- REST 는 웹의 아키텍처로 쓰이도록 만들어진 아키텍처 스타일이다.
- 레스트풀 한 방법으로 HTTP 를 사용하여 어떤 이익도 얻지 못한다면, 다른 종류의 분산 시스템 아키텍처가 더 알맞을 수도 있다.

### 레스트풀 HTTP 서버의 주요 특징

- 리소스가 핵심 개념
    - 각 리소스는 하나의 URI 를 가짐, 각 URI 는 반드시 하나의 리소스를 가리켜야 한다.
    - 리소스는 하나 이상의 포멧에 따라 상태를 판단할 수 있는 표현을 갖게 된다.
- 무상태 의사소통
    - 다른 요청과는 독립적으로 각각의 리소스를 액세스 할 수 있도록 한다. 대규모 확장성 달성.
- 레스트풀 HTTP 에서 메소드는 리소스에 적용할 수 있는 HTTP 동사(GET,PUT,POST,DELETE 등)다.
- 일부 HTTP 메소드는 멱등하다. (오류나 불분명한 결과에도 문제없이 안전하게 다시 호출될 수 있다는 의미)
- 개별 리소스는 스스로 자립할 수 없으며, 리소스는 서로 연결돼 동작한다. (HATEOAS)

### 레스트풀 HTTP 클라이언트의 주요 특징

- 하이퍼미디어의 원칙을 따르는 클라이언트는 다른 애플리케이션이나 호스트, 다른 기업에서 호스팅하는 리소스에도 접근할 수 있다.
- 이상적인 REST 설정에선 클라이언트가 단 하나의 잘 알려진 URI 에서 시작해, 그 다음부턴 하이퍼미디어 제어를 계속 따라가게 된다.

### REST 와 DDD

- 도메인 모델을 레스트풀 HTTP 로 바로 노출하는 것은 좋지 않다.
- 시스템 인터페이스에 별도의 바운디드 컨텍스트를 생성하고 시스템의 인터페이스 모델에서 실제 핵심 도메인으로 액세스하기 위해 적절한 매핑을 사용한다.
    - 시스템 인터페이스 모델에서 핵심 도메인을 분리하기 위해 선호
- 각 표준 미디어 타입을 표현하기 위해 도메인 모델을 생성
    - 표준 미디어 타입을 강조하는 상황에서의 접근법
    - 이렇게 만들어진 도메인 모델은 클라이언트와 서버를 모두 아우르며 재사용할 수도 있다. (공유된 커널, 캐시된 언어)

### 왜 REST 인가

- 설계와 도구사용의 성숙도 때문에 레스트풀 HTTP 는 느슨하게 결합돼야 하고 높은 확장성이 필요한 아키텍처에게 훌륭한 선택이 될 수 있다.

## 커맨드-쿼리 책임 분리

- 엄격한 객체 설계 원칙과 커맨드-쿼리 분리를 아키텍처 패턴으로 녹여내기 위해 노력한 결과
- 객체 수준에서 다음을 의미
    - 메소드가 객체의 상태를 수정한다면, 이 메소드는 커멘드이며 값을 반환하면 안된다.
    - 메소드가 값을 반환한다면, 이 메소드는 쿼리이며 직접적이든 간접적이든 객체 상태의 수정을 야기해선 안 된다.
- 커맨드 메소드와 쿼리 메소드를 모두 갖고 있는 애그리게잇에서 각각을 분리한다.
    - 커맨드 모델과 쿼리 모델은 서로 다른 저장소에 저장된다.

### CQRS 의 영역 살펴보기

#### 클라이언트와 쿼리 처리기

- 쿼리 처리기는 데이터베이스로의 기본 쿼리를 어떻게 실행하는지만을 알고 있는 간단한 컴포넌트를 나타낸다.
- 클라이언트에 제공될때 직렬화 나 DTO 를 만들어서 사용하게 한다.

#### 쿼리 모델(읽기 모델)

- 정규화되지 않은 데이터 모델이다.
- 각 테이블에는 한 가지 종류의 클라이언트 뷰 만을 위한 데이터가 저장된다.
- 주어진 모든 사용자 인터페이스 뷰에서 필요한 정보를 모두 합친 확대 집합을 담아야 할 수도 있다.
- 테이블 뷰는 테이블로부터 생성되고, 각각의 테이블 뷰는 전체 정보의 논리적 하위 집합 으로 사용된다.
- 가급적이면 선택 명령문에선 사용 중인 뷰의 기본 키만을 요구하는 편이 좋다.
- 사용자 인터페이스 뷰 타입마다 하나의 테이블이 연결 되는 패턴을 최대한 따라야 하지만 실용적이도록 하자.

#### 클라이언트가 커맨드 처리를 주도한다

- 사용자 인터페이스 클라이언트는 커맨드 모델 내에 있는 애그리게잇의 행동을 실행시키기 위한 방법으로 서버로 커맨드를 보낸다.
    - 이를 위해, 사용자 인터페이스는 커맨드를 정확히 매개변수화 하는데 필요한 데이터를 수집해야 한다.
    - 명시적인 커맨드를 보낸다는 바람직한 목표를 향해 사용자를 인도해야 한다.
    - 귀납적이고 태스트 주도적인 사용자 인터페이스 설계가 필요하다.

#### 커맨드 처리기

- 보내진 커맨드는 커맨드 핸들러/처리기가 수신한다.
    - 카테고리 스타일
        - 카테고리에 맞춰 애플리케이션 서비스 인터페이스와 구현을 생성.
        - 각 애플리케이션 서비스는 다수의 메소드를 가질 수 있다.
        - 커맨드 각 타입마다 카테고리에 맞는 매개변수로 하나의 메소드를 선언한다.
        - 이해와 생성, 유지 관리가 쉽다.
    - 전용 스타일
        - 하나의 핸들러/처리기당 하나의 책임.
        - 각 핸들러는 독립적으로 재사용될 수 있다.
        - 특정 종류의 커맨드의 양이 많을 때 확장될 수 있다.
- 하나의 핸들러가 다른 핸들러에 의존하지 않도록 한다.
- 커맨드 핸들러가 완성되면 단일 애그리게잇 인스턴스가 업데이트되고, 커맨드 모델에 의해 도메인 이벤트가 게시된다.
    - 쿼리 모델이 업데이트 됐음을 분명히 하기 위한 필수 과정

#### 커맨드 모델(쓰기 모델)은 행동을 수행한다

- 커맨드 모델의 각 커맨드 메소드가 수행되면, 도메인 이벤트를 게시하며 수행이 완료된다.
    - 쿼리 모델을 업데이트 시키기 위함
- 커맨드가 이벤트 퍼블리싱의 결과를 얻지 못할 때
    - 커맨드가 메세징을 통해 적어도 한번 전달됐고 애플리케이션이 멱등한 처리를 보장한다면 재전달된 메세지는 삭제된다.
    - 유효하지 않은 커맨드를 제출하는 권한이 부여되지 않은 모든 클라이언트는 실패하고 메세지는 삭제될 수 있다.

#### 이벤트 구독자가 쿼리 모델을 업데이트한다

- 쿼리 모델이 커맨드 모델에 일어난 가장 최근의 변경을 반영하도록 업데이트 하는 구독자가 커맨드 모델에 의해 게시된 모든 도메인 이벤트를 수신하도록 등록한다.
- 업데이트의 동기, 비동기 여부는 데이터 일관성 제약과 성능 요구사항이 결정에 영향을 준다.
- 새로운 사용자 인터페이스 뷰를 생성했고 그 데이터를 반드시 생성해야 할때
    - 테이블과 테이블 뷰를 설계
    - 여러 기법 중 하나를 선택해 현재 상태로 새 테이블을 채운다.
    - ORM 을 사용한다면 ETL 과 같은 일반적인 데이터 웨어하우징 테크닉을 사용할 수 있다.

### 결국은 일관성이 유지되는 쿼리 모델 다루기

- 쿼리 모델 일관성이 eventually consistent 로 설계됐다면 결과적으로 사용자 인터페이스에서 이질성이 존재하게 된다.
    - 방금 실행된 커맨드의 매개변수로 보내진 데이터를 일시적으로 사용자 인터페이스에 보여주는 방법
    - 사용자가 현재 보고 있는 쿼리 모델의 데이터에 해당하는 시간과 날짜를 항상 사용자 인터페이스에서 명시적으로 보여주는 방법
        - 사용자가 해당 데이터를 사용하기에 너무 오래됐다고 판단하면 그때 새로운 데이터를 요청
        - 적용하기에 앞서 사용자 수용 테스트를 수행할 필요가 있음
    - 이벤트 구독과 같은 지연 업데이트의 또 다른 형태를 사용해 해결
        - 최종적인 일관성까지의 지연 시간이 문제가 될지 신중히 결정
- 사용자 인터페이스가 너무 복잡하진 않거나 정기적으로 여러 애그리게잇에 영향을 미친다면 CQRS 는 피해야 한다.

## 이벤트 주도 아키텍처

### 파이프와 필터

- 파이프는 리눅스의 커맨드라인 파이프와 비슷하며, 필터는 리눅스 커맨드 라인에서 파이프의 입력을 받아 출력을 만드는 명령어들과 비슷하다.
- 리눅스 커맨드 라인의 파이프를 이벤트로, grep, wc 등의 명령어가 각 이벤트 핸들러로 코드를 작성할 경우 유연하다.
- 새로운 필터를 파이프라인에 추가하고 싶다면 기존의 필터가 구독하고 게시할 수 있도록 새로운 이벤트를 생성한다.
- 실제 DDD 시나리오
    - 도메인 이벤트는 비지니스적으로 의미있는 이름을 반영한다.
    - 도메인 전체에 흩어져있는 구독자에게 도움이 될 비지니스 프로세스 활동의 모습을 명시적으로 모델링한다.
    - 핵심을 본명히 나타내도록 고유 식별 정보와 정보를 담고 있는 속성을 묶어준다.

### 장기 실행 프로세스

### 이벤트 소싱

## 데이터 패브릭과 그리드 기반 분산 컴퓨팅

### 데이터 복제

### 이벤트 주도 패브릭과 도메인 이벤트

### 지속적 쿼리

### 분산처리

